{"version":3,"file":"react-final-form.umd.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../src/renderComponent.js","../src/useWhenValueChanges.js","../src/shallowEqual.js","../src/isSyntheticEvent.js","../src/context.js","../src/getters.js","../src/ReactFinalForm.js","../src/useConstant.js","../src/useForm.js","../src/useFormState.js","../src/FormSpy.js","../src/isReactNative.js","../src/getValue.js","../src/useConstantCallback.js","../src/useField.js","../src/useLatest.js","../src/Field.js","../src/index.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","// @flow\nimport * as React from \"react\";\nimport type { RenderableProps } from \"./types\";\n\n// shared logic between components that use either render prop,\n// children render function, or component prop\nexport default function renderComponent<T>(\n  props: RenderableProps<T> & T,\n  lazyProps: Object,\n  name: string,\n): React.Node {\n  const { render, children, component, ...rest } = props;\n  if (component) {\n    return React.createElement(\n      component,\n      Object.assign(lazyProps, rest, {\n        children,\n        render,\n      }),\n    );\n  }\n  if (render) {\n    return render(\n      children === undefined\n        ? Object.assign(lazyProps, rest)\n        : // inject children back in\n          Object.assign(lazyProps, rest, { children }),\n    );\n  }\n  if (typeof children !== \"function\") {\n    throw new Error(\n      `Must specify either a render prop, a render function as children, or a component prop to ${name}`,\n    );\n  }\n  return children(Object.assign(lazyProps, rest));\n}\n","// @flow\nimport React from \"react\";\n\nexport default function useWhenValueChanges(\n  value: any,\n  callback: () => void,\n  isEqual: (any, any) => boolean = (a, b) => a === b,\n) {\n  const previous = React.useRef(value);\n  React.useEffect(() => {\n    if (!isEqual(value, previous.current)) {\n      callback();\n      previous.current = value;\n    }\n  });\n}\n","// @flow\nconst shallowEqual = (a: any, b: any): boolean => {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== \"object\" || !a || typeof b !== \"object\" || !b) {\n    return false;\n  }\n  var keysA = Object.keys(a);\n  var keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(b);\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n    if (!bHasOwnProperty(key) || a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default shallowEqual;\n","// @flow\nconst isSyntheticEvent = (candidate: any): boolean =>\n  !!(candidate && typeof candidate.stopPropagation === \"function\");\n\nexport default isSyntheticEvent;\n","// @flow\nimport * as React from \"react\";\nimport type { FormApi } from \"final-form\";\n\nexport default React.createContext<?FormApi<any>>();\n","import type { FormState, FieldState } from \"final-form\";\n\nconst addLazyState = (dest: Object, state: Object, keys: string[]): void => {\n  keys.forEach((key) => {\n    Object.defineProperty(dest, key, {\n      get: () => state[key],\n      enumerable: true,\n    });\n  });\n};\n\nexport const addLazyFormState = (dest: Object, state: FormState): void =>\n  addLazyState(dest, state, [\n    \"active\",\n    \"dirty\",\n    \"dirtyFields\",\n    \"dirtySinceLastSubmit\",\n    \"dirtyFieldsSinceLastSubmit\",\n    \"error\",\n    \"errors\",\n    \"hasSubmitErrors\",\n    \"hasValidationErrors\",\n    \"initialValues\",\n    \"invalid\",\n    \"modified\",\n    \"modifiedSinceLastSubmit\",\n    \"pristine\",\n    \"submitError\",\n    \"submitErrors\",\n    \"submitFailed\",\n    \"submitSucceeded\",\n    \"submitting\",\n    \"touched\",\n    \"valid\",\n    \"validating\",\n    \"values\",\n    \"visited\",\n  ]);\n\nexport const addLazyFieldMetaState = (dest: Object, state: FieldState): void =>\n  addLazyState(dest, state, [\n    \"active\",\n    \"data\",\n    \"dirty\",\n    \"dirtySinceLastSubmit\",\n    \"error\",\n    \"initial\",\n    \"invalid\",\n    \"length\",\n    \"modified\",\n    \"modifiedSinceLastSubmit\",\n    \"pristine\",\n    \"submitError\",\n    \"submitFailed\",\n    \"submitSucceeded\",\n    \"submitting\",\n    \"touched\",\n    \"valid\",\n    \"validating\",\n    \"visited\",\n  ]);\n","// @flow\nimport * as React from \"react\";\nimport {\n  createForm,\n  formSubscriptionItems,\n  version as ffVersion,\n} from \"final-form\";\nimport type {\n  FormApi,\n  Config,\n  FormSubscription,\n  FormState,\n  FormValuesShape,\n  Unsubscribe,\n} from \"final-form\";\nimport type { FormProps as Props, SubmitEvent } from \"./types\";\nimport renderComponent from \"./renderComponent\";\nimport useWhenValueChanges from \"./useWhenValueChanges\";\nimport useConstant from \"./useConstant\";\nimport shallowEqual from \"./shallowEqual\";\nimport isSyntheticEvent from \"./isSyntheticEvent\";\nimport type { FormRenderProps } from \"./types.js.flow\";\nimport ReactFinalFormContext from \"./context\";\nimport useLatest from \"./useLatest\";\nimport { version } from \"../package.json\";\nimport { addLazyFormState } from \"./getters\";\n\nexport { version };\n\nconst versions = {\n  \"final-form\": ffVersion,\n  \"react-final-form\": version,\n};\n\nexport const all: FormSubscription = formSubscriptionItems.reduce(\n  (result, key) => {\n    result[key] = true;\n    return result;\n  },\n  {},\n);\n\nfunction ReactFinalForm<FormValues: FormValuesShape>({\n  debug,\n  decorators = [],\n  destroyOnUnregister,\n  form: alternateFormApi,\n  initialValues,\n  initialValuesEqual,\n  keepDirtyOnReinitialize,\n  mutators,\n  onSubmit,\n  subscription = all,\n  validate,\n  validateOnBlur,\n  ...rest\n}: Props<FormValues>) {\n  const config: Config<FormValues> = {\n    debug,\n    destroyOnUnregister,\n    initialValues,\n    keepDirtyOnReinitialize,\n    mutators,\n    onSubmit,\n    validate,\n    validateOnBlur,\n  };\n\n  const form: FormApi<FormValues> = useConstant(() => {\n    const f = alternateFormApi || createForm<FormValues>(config);\n    // pause validation until children register all fields on first render (unpaused in useEffect() below)\n    f.pauseValidation();\n    return f;\n  });\n\n  // synchronously register and unregister to query form state for our subscription on first render\n  const [state, setState] = React.useState<FormState<FormValues>>(\n    (): FormState<FormValues> => {\n      let initialState: FormState<FormValues> = {};\n      form.subscribe((state) => {\n        initialState = state;\n      }, subscription)();\n      return initialState;\n    },\n  );\n\n  // save a copy of state that can break through the closure\n  // on the shallowEqual() line below.\n  const stateRef = React.useRef<FormState>(state);\n  stateRef.current = state;\n\n  React.useEffect(() => {\n    // We have rendered, so all fields are now registered, so we can unpause validation\n    form.isValidationPaused() && form.resumeValidation();\n    const unsubscriptions: Unsubscribe[] = [\n      form.subscribe((s) => {\n        if (!shallowEqual(s, stateRef.current)) {\n          setState(s);\n        }\n      }, subscription),\n      ...(decorators\n        ? decorators.map((decorator) =>\n            // this noop ternary is to appease the flow gods\n            // istanbul ignore next\n            decorator(form),\n          )\n        : []),\n    ];\n\n    return () => {\n      form.pauseValidation(); // pause validation so we don't revalidate on every field deregistration\n      unsubscriptions.reverse().forEach((unsubscribe) => unsubscribe());\n      // don't need to resume validation here; either unmounting, or will re-run this hook with new deps\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, decorators);\n\n  // warn about decorator changes\n  // istanbul ignore next\n  if (process.env.NODE_ENV !== \"production\") {\n    // You're never supposed to use hooks inside a conditional, but in this\n    // case we can be certain that you're not going to be changing your\n    // NODE_ENV between renders, so this is safe.\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useWhenValueChanges(\n      decorators,\n      () => {\n        console.error(\n          \"Form decorators should not change from one render to the next as new values will be ignored\",\n        );\n      },\n      shallowEqual,\n    );\n  }\n\n  // allow updatable config\n  useWhenValueChanges(debug, () => {\n    form.setConfig(\"debug\", debug);\n  });\n  useWhenValueChanges(destroyOnUnregister, () => {\n    form.destroyOnUnregister = !!destroyOnUnregister;\n  });\n  useWhenValueChanges(keepDirtyOnReinitialize, () => {\n    form.setConfig(\"keepDirtyOnReinitialize\", keepDirtyOnReinitialize);\n  });\n  useWhenValueChanges(\n    initialValues,\n    () => {\n      form.setConfig(\"initialValues\", initialValues);\n    },\n    initialValuesEqual || shallowEqual,\n  );\n  useWhenValueChanges(mutators, () => {\n    form.setConfig(\"mutators\", mutators);\n  });\n  useWhenValueChanges(onSubmit, () => {\n    form.setConfig(\"onSubmit\", onSubmit);\n  });\n  useWhenValueChanges(validate, () => {\n    form.setConfig(\"validate\", validate);\n  });\n  useWhenValueChanges(validateOnBlur, () => {\n    form.setConfig(\"validateOnBlur\", validateOnBlur);\n  });\n\n  const handleSubmit = (event: ?SubmitEvent) => {\n    if (event) {\n      // sometimes not true, e.g. React Native\n      if (typeof event.preventDefault === \"function\") {\n        event.preventDefault();\n      }\n      if (typeof event.stopPropagation === \"function\") {\n        // prevent any outer forms from receiving the event too\n        event.stopPropagation();\n      }\n    }\n    return form.submit();\n  };\n\n  const renderProps: FormRenderProps<FormValues> = {\n    form: {\n      ...form,\n      reset: (eventOrValues) => {\n        if (isSyntheticEvent(eventOrValues)) {\n          // it's a React SyntheticEvent, call reset with no arguments\n          form.reset();\n        } else {\n          form.reset(eventOrValues);\n        }\n      },\n    },\n    handleSubmit,\n  };\n  addLazyFormState(renderProps, state);\n  return React.createElement(\n    ReactFinalFormContext.Provider,\n    { value: form },\n    renderComponent(\n      {\n        ...rest,\n        __versions: versions,\n      },\n      renderProps,\n      \"ReactFinalForm\",\n    ),\n  );\n}\n\nexport default ReactFinalForm;\n","// @flow\nimport React from \"react\";\n\n/**\n * A simple hook to create a constant value that lives for\n * the lifetime of the component.\n *\n * Plagiarized from https://github.com/Andarist/use-constant\n *\n * Do NOT reuse this code unless you know what you're doing.\n * Use Andarist's hook; it's more fault tolerant to things like\n * falsy values.\n *\n * @param {Function} init - A function to generate the value\n */\nexport default function useConstant<T>(init: () => T): T {\n  const ref = React.useRef<?T>();\n  if (!ref.current) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n","// @flow\nimport * as React from \"react\";\nimport type { FormApi, FormValuesShape } from \"final-form\";\nimport ReactFinalFormContext from \"./context\";\n\nfunction useForm<FormValues: FormValuesShape>(\n  componentName?: string,\n): FormApi<FormValues> {\n  const form: ?FormApi<FormValues> = React.useContext(ReactFinalFormContext);\n  if (!form) {\n    throw new Error(\n      `${componentName || \"useForm\"} must be used inside of a <Form> component`,\n    );\n  }\n  return form;\n}\n\nexport default useForm;\n","// @flow\nimport * as React from \"react\";\nimport type { UseFormStateParams } from \"./types\";\nimport type { FormState, FormApi, FormValuesShape } from \"final-form\";\nimport { all } from \"./ReactFinalForm\";\nimport useForm from \"./useForm\";\nimport { addLazyFormState } from \"./getters\";\n\nfunction useFormState<FormValues: FormValuesShape>({\n  onChange,\n  subscription = all,\n}: UseFormStateParams<FormValues> = {}): FormState<FormValues> {\n  const form: FormApi<FormValues> = useForm<FormValues>(\"useFormState\");\n  const firstRender = React.useRef(true);\n  const onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  // synchronously register and unregister to query field state for our subscription on first render\n  const [state, setState] = React.useState<FormState<FormValues>>(\n    (): FormState<FormValues> => {\n      let initialState: FormState<FormValues> = {};\n      form.subscribe((state) => {\n        initialState = state;\n      }, subscription)();\n      if (onChange) {\n        onChange(initialState);\n      }\n      return initialState;\n    },\n  );\n\n  React.useEffect(\n    () =>\n      form.subscribe((newState) => {\n        if (firstRender.current) {\n          firstRender.current = false;\n        } else {\n          setState(newState);\n          if (onChangeRef.current) {\n            onChangeRef.current(newState);\n          }\n        }\n      }, subscription),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [],\n  );\n  const lazyState = {};\n  addLazyFormState(lazyState, state);\n  return lazyState;\n}\n\nexport default useFormState;\n","// @flow\nimport renderComponent from \"./renderComponent\";\nimport type {\n  FormSpyPropsWithForm as Props,\n  FormSpyRenderProps,\n} from \"./types\";\nimport type { FormValuesShape } from \"final-form\";\nimport isSyntheticEvent from \"./isSyntheticEvent\";\nimport useForm from \"./useForm\";\nimport useFormState from \"./useFormState\";\n\nfunction FormSpy<FormValues: FormValuesShape>({\n  onChange,\n  subscription,\n  ...rest\n}: Props<FormValues>) {\n  const reactFinalForm = useForm<FormValues>(\"FormSpy\");\n  const state = useFormState({ onChange, subscription });\n  if (onChange) {\n    return null;\n  }\n\n  const renderProps: FormSpyRenderProps<FormValues> = {\n    form: {\n      ...reactFinalForm,\n      reset: (eventOrValues) => {\n        if (isSyntheticEvent(eventOrValues)) {\n          // it's a React SyntheticEvent, call reset with no arguments\n          reactFinalForm.reset();\n        } else {\n          reactFinalForm.reset(eventOrValues);\n        }\n      },\n    },\n  };\n  return renderComponent(\n    {\n      ...rest,\n      ...renderProps,\n    },\n    state,\n    \"FormSpy\",\n  );\n}\n\nexport default FormSpy;\n","// @flow\nconst isReactNative =\n  typeof window !== \"undefined\" &&\n  window.navigator &&\n  window.navigator.product &&\n  window.navigator.product === \"ReactNative\";\n\nexport default isReactNative;\n","// @flow\nconst getSelectedValues = (options) => {\n  const result = [];\n  if (options) {\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n      if (option.selected) {\n        result.push(option.value);\n      }\n    }\n  }\n  return result;\n};\n\nconst getValue = (\n  event: SyntheticInputEvent<*>,\n  currentValue: any,\n  valueProp: any,\n  isReactNative: boolean,\n) => {\n  if (\n    !isReactNative &&\n    event.nativeEvent &&\n    (event.nativeEvent: Object).text !== undefined\n  ) {\n    return (event.nativeEvent: Object).text;\n  }\n  if (isReactNative && event.nativeEvent) {\n    return (event.nativeEvent: any).text;\n  }\n  const detypedEvent: any = event;\n  const {\n    target: { type, value, checked },\n  } = detypedEvent;\n  switch (type) {\n    case \"checkbox\":\n      if (valueProp !== undefined) {\n        // we are maintaining an array, not just a boolean\n        if (checked) {\n          // add value to current array value\n          return Array.isArray(currentValue)\n            ? currentValue.concat(valueProp)\n            : [valueProp];\n        } else {\n          // remove value from current array value\n          if (!Array.isArray(currentValue)) {\n            return currentValue;\n          }\n          const index = currentValue.indexOf(valueProp);\n          if (index < 0) {\n            return currentValue;\n          } else {\n            return currentValue\n              .slice(0, index)\n              .concat(currentValue.slice(index + 1));\n          }\n        }\n      } else {\n        // it's just a boolean\n        return !!checked;\n      }\n    case \"select-multiple\":\n      return getSelectedValues((event.target: any).options);\n    default:\n      return value;\n  }\n};\n\nexport default getValue;\n","// @flow\nimport * as React from \"react\";\n\n/**\n * Creates a callback, even with closures, that will be\n * instance === for the lifetime of the component, always\n * calling the most recent version of the function and its\n * closures.\n */\nexport default function useConstantCallback(callback) {\n  const ref = React.useRef(callback);\n  React.useEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback((...args) => ref.current.apply(null, args), []);\n}\n","// @flow\nimport * as React from \"react\";\nimport { fieldSubscriptionItems } from \"final-form\";\nimport type {\n  FieldSubscription,\n  FieldState,\n  FormApi,\n  FormValuesShape,\n} from \"final-form\";\nimport type {\n  UseFieldConfig,\n  FieldInputProps,\n  FieldRenderProps,\n} from \"./types\";\nimport isReactNative from \"./isReactNative\";\nimport getValue from \"./getValue\";\nimport useForm from \"./useForm\";\nimport useLatest from \"./useLatest\";\nimport { addLazyFieldMetaState } from \"./getters\";\nimport useConstantCallback from \"./useConstantCallback\";\n\nconst all: FieldSubscription = fieldSubscriptionItems.reduce((result, key) => {\n  result[key] = true;\n  return result;\n}, {});\n\nconst defaultFormat = (value: ?any, name: string) =>\n  value === undefined ? \"\" : value;\nconst defaultParse = (value: ?any, name: string) =>\n  value === \"\" ? undefined : value;\n\nconst defaultIsEqual = (a: any, b: any): boolean => a === b;\n\nfunction useField<FormValues: FormValuesShape>(\n  name: string,\n  config: UseFieldConfig = {},\n): FieldRenderProps {\n  const {\n    afterSubmit,\n    allowNull,\n    component,\n    data,\n    defaultValue,\n    format = defaultFormat,\n    formatOnBlur,\n    initialValue,\n    multiple,\n    parse = defaultParse,\n    subscription = all,\n    type,\n    validateFields,\n    value: _value,\n  } = config;\n  const form: FormApi<FormValues> = useForm<FormValues>(\"useField\");\n\n  const configRef = useLatest(config);\n\n  const register = (callback: (FieldState) => void, silent: boolean) =>\n    // avoid using `state` const in any closures created inside `register`\n    // because they would refer `state` from current execution context\n    // whereas actual `state` would defined in the subsequent `useField` hook\n    // execution\n    // (that would be caused by `setState` call performed in `register` callback)\n    form.registerField(name, callback, subscription, {\n      afterSubmit,\n      beforeSubmit: () => {\n        const {\n          beforeSubmit,\n          formatOnBlur,\n          format = defaultFormat,\n        } = configRef.current;\n\n        if (formatOnBlur) {\n          const { value } = ((form.getFieldState(name): any): FieldState);\n          const formatted = format(value, name);\n\n          if (formatted !== value) {\n            form.change(name, formatted);\n          }\n        }\n\n        return beforeSubmit && beforeSubmit();\n      },\n      data,\n      defaultValue,\n      getValidator: () => configRef.current.validate,\n      initialValue,\n      isEqual: (a, b) => (configRef.current.isEqual || defaultIsEqual)(a, b),\n      silent,\n      validateFields,\n    });\n\n  const firstRender = React.useRef(true);\n\n  // synchronously register and unregister to query field state for our subscription on first render\n  const [state, setState] = React.useState<FieldState>((): FieldState => {\n    let initialState: FieldState = {};\n\n    // temporarily disable destroyOnUnregister\n    const destroyOnUnregister = form.destroyOnUnregister;\n    form.destroyOnUnregister = false;\n\n    register((state) => {\n      initialState = state;\n    }, true)();\n\n    // return destroyOnUnregister to its original value\n    form.destroyOnUnregister = destroyOnUnregister;\n\n    return initialState;\n  });\n\n  React.useEffect(\n    () =>\n      register((state) => {\n        if (firstRender.current) {\n          firstRender.current = false;\n        } else {\n          setState(state);\n        }\n      }, false),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      name,\n      data,\n      defaultValue,\n      // If we want to allow inline fat-arrow field-level validation functions, we\n      // cannot reregister field every time validate function !==.\n      // validate,\n      initialValue,\n      // The validateFields array is often passed as validateFields={[]}, creating\n      // a !== new array every time. If it needs to be changed, a rerender/reregister\n      // can be forced by changing the key prop\n      // validateFields\n    ],\n  );\n\n  const meta = {};\n  addLazyFieldMetaState(meta, state);\n  const input: FieldInputProps = {\n    name,\n    get value() {\n      let value = state.value;\n      if (formatOnBlur) {\n        if (component === \"input\") {\n          value = defaultFormat(value, name);\n        }\n      } else {\n        value = format(value, name);\n      }\n      if (value === null && !allowNull) {\n        value = \"\";\n      }\n      if (type === \"checkbox\" || type === \"radio\") {\n        return _value;\n      } else if (component === \"select\" && multiple) {\n        return value || [];\n      }\n      return value;\n    },\n    get checked() {\n      let value = state.value;\n      if (type === \"checkbox\") {\n        value = format(value, name);\n        if (_value === undefined) {\n          return !!value;\n        } else {\n          return !!(Array.isArray(value) && ~value.indexOf(_value));\n        }\n      } else if (type === \"radio\") {\n        return format(value, name) === _value;\n      }\n      return undefined;\n    },\n    onBlur: useConstantCallback((event: ?SyntheticFocusEvent<*>) => {\n      state.blur();\n      if (formatOnBlur) {\n        /**\n         * Here we must fetch the value directly from Final Form because we cannot\n         * trust that our `state` closure has the most recent value. This is a problem\n         * if-and-only-if the library consumer has called `onChange()` immediately\n         * before calling `onBlur()`, but before the field has had a chance to receive\n         * the value update from Final Form.\n         */\n        const fieldState: any = form.getFieldState(state.name);\n        state.change(format(fieldState.value, state.name));\n      }\n    }),\n    onChange: useConstantCallback((event: SyntheticInputEvent<*> | any) => {\n      // istanbul ignore next\n      if (process.env.NODE_ENV !== \"production\" && event && event.target) {\n        const targetType = event.target.type;\n        const unknown =\n          ~[\"checkbox\", \"radio\", \"select-multiple\"].indexOf(targetType) &&\n          !type &&\n          component !== \"select\";\n\n        const value: any =\n          targetType === \"select-multiple\" ? state.value : _value;\n\n        if (unknown) {\n          console.error(\n            `You must pass \\`type=\"${\n              targetType === \"select-multiple\" ? \"select\" : targetType\n            }\"\\` prop to your Field(${name}) component.\\n` +\n              `Without it we don't know how to unpack your \\`value\\` prop - ${\n                Array.isArray(value) ? `[${value}]` : `\"${value}\"`\n              }.`,\n          );\n        }\n      }\n\n      const value: any =\n        event && event.target\n          ? getValue(event, state.value, _value, isReactNative)\n          : event;\n      state.change(parse(value, name));\n    }),\n    onFocus: useConstantCallback((event: ?SyntheticFocusEvent<*>) =>\n      state.focus(),\n    ),\n  };\n\n  if (multiple) {\n    input.multiple = multiple;\n  }\n  if (type !== undefined) {\n    input.type = type;\n  }\n\n  const renderProps: FieldRenderProps = { input, meta }; // assign to force Flow check\n  return renderProps;\n}\n\nexport default useField;\n","// @flow\nimport React from \"react\";\n\nexport default function useLatest<T>(value: T): { +current: T } {\n  const ref = React.useRef(value);\n\n  React.useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref;\n}\n","// @flow\nimport * as React from \"react\";\nimport type { FieldProps as Props, FieldRenderProps } from \"./types\";\nimport renderComponent from \"./renderComponent\";\nimport useField from \"./useField\";\n\nconst Field = React.forwardRef<any, Props>(function Field(\n  {\n    afterSubmit,\n    allowNull,\n    beforeSubmit,\n    children,\n    component,\n    data,\n    defaultValue,\n    format,\n    formatOnBlur,\n    initialValue,\n    isEqual,\n    multiple,\n    name,\n    parse,\n    subscription,\n    type,\n    validate,\n    validateFields,\n    value,\n    ...rest\n  }: Props,\n  ref,\n) {\n  const field: FieldRenderProps = useField(name, {\n    afterSubmit,\n    allowNull,\n    beforeSubmit,\n    children,\n    component,\n    data,\n    defaultValue,\n    format,\n    formatOnBlur,\n    initialValue,\n    isEqual,\n    multiple,\n    parse,\n    subscription,\n    type,\n    validate,\n    validateFields,\n    value,\n  });\n\n  if (typeof children === \"function\") {\n    return (children: Function)({ ...field, ...rest });\n  }\n\n  if (typeof component === \"string\") {\n    // ignore meta, combine input with any other props\n    return React.createElement(component, {\n      ...field.input,\n      children,\n      ref,\n      ...rest,\n    });\n  }\n\n  if (!name) {\n    throw new Error(\"prop name cannot be undefined in <Field> component\");\n  }\n\n  return renderComponent(\n    { children, component, ref, ...rest },\n    field,\n    `Field(${name})`,\n  );\n});\n\nexport default Field;\n","// @flow\nimport Form from \"./ReactFinalForm\";\nimport FormSpy from \"./FormSpy\";\nexport { default as Field } from \"./Field\";\nexport { default as Form, version } from \"./ReactFinalForm\";\nexport { default as FormSpy } from \"./FormSpy\";\nexport { default as useField } from \"./useField\";\nexport { default as useFormState } from \"./useFormState\";\nexport { default as useForm } from \"./useForm\";\nexport function withTypes() {\n  return { Form, FormSpy };\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","key","source","prototype","hasOwnProperty","call","apply","this","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","renderComponent","props","lazyProps","name","render","children","component","rest","React","createElement","undefined","Error","useWhenValueChanges","value","callback","isEqual","a","b","previous","useRef","useEffect","current","shallowEqual","keysA","keysB","bHasOwnProperty","bind","idx","isSyntheticEvent","candidate","stopPropagation","createContext","addLazyState","dest","state","forEach","defineProperty","get","enumerable","addLazyFormState","versions","ffVersion","version","all","formSubscriptionItems","reduce","result","ReactFinalForm","debug","decorators","destroyOnUnregister","alternateFormApi","form","initialValues","initialValuesEqual","keepDirtyOnReinitialize","mutators","onSubmit","subscription","validate","validateOnBlur","config","init","f","createForm","pauseValidation","ref","useState","initialState","subscribe","setState","stateRef","isValidationPaused","resumeValidation","unsubscriptions","s","map","decorator","reverse","unsubscribe","setConfig","renderProps","reset","eventOrValues","handleSubmit","event","preventDefault","submit","ReactFinalFormContext","Provider","__versions","useForm","componentName","useContext","useFormState","onChange","firstRender","onChangeRef","newState","lazyState","FormSpy","reactFinalForm","isReactNative","window","navigator","product","getSelectedValues","options","index","option","selected","push","useConstantCallback","useCallback","args","defaultFormat","defaultParse","defaultIsEqual","fieldSubscriptionItems","useField","register","silent","registerField","afterSubmit","beforeSubmit","configRef","formatOnBlur","format","formatted","getFieldState","change","data","defaultValue","getValidator","initialValue","validateFields","allowNull","multiple","parse","type","_value","meta","input","Array","isArray","onBlur","fieldState","blur","currentValue","valueProp","nativeEvent","text","checked","concat","slice","getValue","onFocus","focus","Field","forwardRef","field","Form"],"mappings":"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"}